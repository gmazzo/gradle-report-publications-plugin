/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package io.github.gmazzo.publications.report

import io.github.gmazzo.publications.report.ReportPublicationSerializer.deserialize
import io.github.gmazzo.publications.report.ReportPublicationSerializer.serialize
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.flow.FlowProviders
import org.gradle.api.flow.FlowScope
import org.gradle.api.internal.GradleInternal
import org.gradle.api.invocation.Gradle
import org.gradle.api.provider.MapProperty
import org.gradle.api.publish.maven.MavenArtifact
import org.gradle.api.publish.maven.tasks.AbstractPublishToMaven
import org.gradle.api.publish.maven.tasks.PublishToMavenLocal
import org.gradle.api.publish.maven.tasks.PublishToMavenRepository
import org.gradle.build.event.BuildEventsListenerRegistry
import org.gradle.kotlin.dsl.always
import org.gradle.kotlin.dsl.apply
import org.gradle.kotlin.dsl.mapProperty
import org.gradle.kotlin.dsl.named
import org.gradle.kotlin.dsl.registerIfAbsent
import org.gradle.kotlin.dsl.withType
import javax.inject.Inject

class ReportPublicationsPlugin @Inject constructor(
    private val buildEventsListenerRegistry: BuildEventsListenerRegistry,
    private val flowScope: FlowScope,
    private val flowProviders: FlowProviders,
) : Plugin<Project> {

    override fun apply(project: Project): Unit = with(project) {
        if (project != rootProject) {
            rootProject.apply<ReportPublicationsPlugin>()
            return
        }

        val service = gradle.sharedServices.registerIfAbsent("publicationsReport", ReportPublicationsService::class) {}
        val publications = with(gradle.rootBuild().extensions) {
            findByName("publicationsReport") as MapProperty<String, ByteArray>?
                ?: rootProject.objects.mapProperty<String, ByteArray>().also { add("publicationsReport", it) }
        }

        buildEventsListenerRegistry.onTaskCompletion(service)

        if (gradle.parent == null) {
            flowScope.always(ReportPublicationsFlowAction::class) {
                parameters.publications.set(flowProviders.buildWorkResult.zip(publications) { _, publications ->
                    publications.mapValues { (_, it) -> deserialize(it) }
                })
                parameters.outcomes.set(flowProviders.buildWorkResult.zip(service) { _, it -> it.tasksOutcome })
            }
        }

        val buildPath = gradle.path
        gradle.allprojects {
            tasks.withType<AbstractPublishToMaven>().configureEach {
                publications.putAll(tasks.named<AbstractPublishToMaven>(this@configureEach.name)
                    .map { mapOf( buildPath + it.path to serialize(resolvePublication(it))) })
            }
        }
    }

    private fun resolvePublication(task: AbstractPublishToMaven): ReportPublication {
        val repository = when (task) {
            is PublishToMavenLocal -> ReportPublication.Repository(
                name = "mavenLocal",
                value = "~/.m2/repository"
            )

            is PublishToMavenRepository -> ReportPublication.Repository(
                name = task.repository.name,
                task.repository.url.toString()
            )

            else -> ReportPublication.Repository(name = "<unknown>", value = "")
        }
        val artifacts = task.publication.artifacts.sortedWith(compareBy(MavenArtifact::getClassifier)).map {
            when (val classifier = it.classifier) {
                null -> it.extension
                else -> "$classifier.${it.extension}"
            }
        }.ifEmpty { listOf("pom") }

        return ReportPublication(
            groupId = task.publication.groupId,
            artifactId = task.publication.artifactId,
            version = task.publication.version,
            repository = repository,
            outcome = ReportPublication.Outcome.NotRun,
            artifacts = artifacts
        )
    }

    private tailrec fun Gradle.rootBuild(): Gradle = when (val parent = parent) {
        null -> this
        else -> parent.rootBuild()
    }

    @Suppress("RecursivePropertyAccessor")
    private val Gradle.path: String
        get() = when (val parent = parent) {
            null -> ""
            else -> "${parent.path}${(this as GradleInternal).identityPath}"
        }

}
